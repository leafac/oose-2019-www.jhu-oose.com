# Assignment 9: Programming Paradigms

# Find the Refactoring Technique

<small>
**5 points**
</small>

We started the lecture discussing the [tradeoffs between functional and object-oriented programming](/lectures/9#object-oriented-vs-functional-programming). The following is code in a _functional style_:

```javascript
class Rock {}
class Paper {}
class Scissors {}

function toString(playerChoice) {
  if (playerChoice instanceof Rock) return "ğŸ’";
  if (playerChoice instanceof Paper) return "ğŸ§»";
  if (playerChoice instanceof Scissors) return "âœ‚ï¸";
}
```

And the following is the same code in an _object-oriented style_:

```javascript
class Rock {
  toString() {
    return "ğŸ’";
  }
}

class Paper {
  toString() {
    return "ğŸ“„";
  }
}

class Scissors {
  toString() {
    return "âœ‚ï¸";
  }
}
```

As it turns out, thereâ€™s a refactoring technique from the [catalog of refactorings](/lectures/8#refactoring) to go from the first version to the second. What is it?

# Refactoring Beyond Techniques

<small>
**5 points**
</small>

As discussed in lecture, our implementation of the `beats()` function in Version 2 was mechanical: we just rearranged code from Version 1 and it ended up like this:

```javascript
function beats(thisPlayerChoice, otherPlayerChoice) {
  if (thisPlayerChoice instanceof Rock)
    return otherPlayerChoice instanceof Scissors;
  if (thisPlayerChoice instanceof Paper)
    return otherPlayerChoice instanceof Rock;
  if (thisPlayerChoice instanceof Scissors)
    return otherPlayerChoice instanceof Paper;
}
```

But code in a functional style doesnâ€™t have to be this confusing mess of `if`s and `return`s. Refactor this function such that all the `if`s are gone and thereâ€™s only one `return`. The behavior of the function must remain the same (otherwise it isnâ€™t really a refactoring, is it?). As far as I call tell, there isnâ€™t a technique for this in the catalog.

# Unduck Typing

<small>
**10 points**
</small>

Translate the code we discussed in [the part of the lecture about Duck Typing](/lectures/9#duck-typing) to Java. Keep the definition of `randomChoice()` in a _functional style_.

# Unmonkey Patching

<small>
**15 points**
</small>

In lecture we [monkey patched JavaScriptâ€™s `Array`s to include a `sample()` method](/lectures/9#monkey-patching). Javaâ€™s `List`s also donâ€™t have such method:

```java
import java.util.List;

public class Main {
    public static void main(String[] args) {
        var choices = List.of("ğŸ’", "ğŸ“„", "âœ‚ï¸");
        var rock = choices.get(0); // ğŸ‘  Works
        var player1Choice = choices.sample(); // âš ï¸  Doesnâ€™t exist
    }
}
```

Luckily, for any feature that our language doesnâ€™t have, thereâ€™s a [design pattern](/lectures/3) to work around it.

Whatâ€™s that design pattern? (It may or many have been covered previously in the course; consult the [catalog](/lectures/3#references) if necessary.)

Complete the code below, only changing the parts that are indicated:

```java
import java.util.List;

// Below is my implementation of the ___ design pattern:

// ___ Implementation goes here ____

public class Main {
    public static void main(String[] args) {
        var choices = List.of("ğŸ’", "ğŸ“„", "âœ‚ï¸");
        var choicesExtendedWithSampleMethod = ___ choices ___; // Use the design pattern here.
        var rock = choicesExtendedWithSampleMethod.get(0); // ğŸ‘  Works
        var player1Choice = choicesExtendedWithSampleMethod.sample(); //Â ğŸ‘  Works
    }
}
```

# Mixins

<small>
**15 points**
</small>

I wish I could convert my rocks both to JSON and to XML:

```javascript
class Rock {
  toString() {
    return "ğŸ’";
  }
}
class JsonableRock extends Rock {
  toJson() {
    return `{ "rock": "${this}" }`;
  }
}
class XmlableRock extends Rock {
  toXml() {
    return `<rock>${this}</rock>`;
  }
}
// âš ï¸  The following doesnâ€™t work because JavaScript
//     (or Java, for that matter) doesnâ€™t support multiple inheritance.
class JsonableAndXmlableRock extends JsonableRock, XmlableRock {}

const jsonableAndXmlableRock = new JsonableAndXmlableRock();

console.log(jsonableAndXmlableRock.toJson());
console.log(jsonableAndXmlableRock.toXml());
```

1. Help me turn `JsonableRock` into a [mixin](/lectures/9#mixins) called `jsonableRockMixin()` and turn `XmlableRock` into a mixin called `xmlableRockMixin()`. Then show how to define the `JsonableAndXmlableRock` class. Donâ€™t change the definitions of the `Rock` class and the `jsonableAndXmlableRock` variable, and donâ€™t change the `console.log()` lines.

2. What if we renamed both `toJson()` and `toXml()` to `serialize()`? Which implementation would be called when we call `jsonableAndXmlableRock.serialize()`? How can we change the definition of `JsonableAndXmlableRock` to make the other implementation be called?

# `this` Makes Sense

<small>
**25 points**
</small>

I was playing with the Rockâ€“Paperâ€“Scissors game and I came up with the following component (for your convenience, I pushed the code to the [`this-makes-sense` branch in the TODOOSE repository](https://github.com/jhu-oose/todoose/tree/this-makes-sense)):

```jsx
class Rock extends React.Component {
  toString() {
    return "ğŸ’";
  }

  handleClick() {
    alert(`You clicked ${this}`);
  }

  render() {
    return (
      <button
        onClick={() => {
          this.handleClick();
        }}
      >
        {this.toString()}
      </button>
    );
  }
}
```

The function passed to `onClick` seemed silly to me: it just calls `this.handleClick`, but `this.handleClick` is already a function. I wanted to cut the intermediary and pass `this.handleClick` to `onClick` directly, like this:

```jsx
class Rock extends React.Component {
  toString() {
    return "ğŸ’";
  }

  handleClick() {
    alert(`You clicked ${this}`);
  }

  render() {
    return <button onClick={this.handleClick}>{this.toString()}</button>;
  }
}
```

But that didnâ€™t work! When I clicked on the button, it said â€œYou clicked undefinedâ€.

I looked around and found an incantation that fixed the issue: `this.handleClick = this.handleClick.bind(this)`. Hereâ€™s how the code turned out:

```jsx
class Rock extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }

  toString() {
    return "ğŸ’";
  }

  handleClick() {
    alert(`You clicked ${this}`);
  }

  render() {
    return <button onClick={this.handleClick}>{this.toString()}</button>;
  }
}
```

But Iâ€™m not sure I understand whatâ€™s going on:

1. Why did I see â€œYou clicked undefinedâ€ before I introduced that incantation?

2. How does the incantation work, and why does it fix the issue?

Some links to help you with this question:

- [The React documentation on event handlers](https://reactjs.org/docs/handling-events.html).

- [The documentation for the `bind()` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind). As it turns out this behavior has nothing to do with React in particularâ€”itâ€™s about JavaScript in general!

- [A blog post about `bind()`](https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/).

- [A blog post that pretty much answers this question](https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/). But we want an explanation in your own words.

- [A blog post discussing the `this` keyword in JavaScript](https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/).

- In TODOOSE, to keep things simple, we [sidestepped this issue](https://github.com/jhu-oose/todoose/blob/1608e75189822bd36b5b86d1f4f43830bb935b76/src/main/resources/public/javascripts/components/ItemsComponents.js#L7) by using code that looks like the first version written in this question.

# Object-Oriented vs. Functional Programming in React

<small>
**25 points**
</small>

Read [the remainder section on object-oriented programming](/lectures/9#classes-dont-have-parents-objects-have-prototypes), [the section on function programming](/lectures/9#functional-programming-in-depth), and for fun [the section on other paradigms](/lectures/9#other-paradigms). Reflect on the questions you find there. Ask follow-up questions on [the forum](https://github.com/jhu-oose/2019-students/issues){:data-proofer-ignore="true"}Â <small title="You must be a registered student logged into GitHub to see this.">ğŸ”’</small> and during office hours.

Now letâ€™s critique the design of React. Go over the [Main Concepts (Â§Â 1â€“12)](https://reactjs.org/docs/hello-world.html). Some concepts in React are in an object-oriented style, while others are in a functional style. For example, it uses objects (object-oriented), but it favors immutability and avoids side-effects (functional). Write about which parts of the design are object-oriented and which parts are functional, and why. Also, say why do you think these aspects are well designed or not. You donâ€™t need to be exhaustive and talk about _everything_ covered in Main Concepts, just what you find worth discussing.

# Departing Note

**â€œOh my god, your assignments are so vague!â€**

Exactly! Vague requirements: thatâ€™s the life of a software engineer! Lucky for you, this is the last assignment written by me <small>ğŸ˜‰</small> (The next and final assignment will be written by our [Head CA](/staff#head-course-assistanthead-ca-yash-kumar-lal).)

The key to success is to start working early, talk to your colleagues, go to office hours, ask questions on the forum, show the staff your partial answers to check if youâ€™re headed on the right direction, and so forth.

Ask questions such as: Whatâ€™s the target audience of this explanation? What can I expect my readers to already know? Is this idea better explained with an example (hint: it _always_ is!)? And so forth.

**Thanks for sticking around and I hope you have as much fun answering these assignments as I had coming up with them.**

{% include assignment_submission_form.md assignment="9" %}
